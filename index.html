<!DOCTYPE html>
    <head>
        <meta charset="utf-8">
        <title>Bikes picked up</title>
        <script src="https://d3js.org/d3.v3.min.js"></script>
        <script src="https://d3js.org/topojson.v1.min.js"></script>
        <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
        <script src="d3.promise.js"></script>
        <script src="q.js"></script>

        <style>
            path.disctrict {
                stroke: #777;
                stroke-width: 2px;
            }
        </style>
    </head>
    <body>
        <h1 style="text-align: center;">Bikes picked up at: <span id="SelectedTime">00:00</span> on the 27<sup>th</sup> of June, 2016</h1>
        <input type="range" min="0" max="46" step="1" id="time" value="0" style="width:98%; box-sizing:border-box;" />

        <script>
            var width = window.innerWidth-40,
                height = window.innerHeight-120,
                projection,
                sates,
                path,
                munich,
                timeslots,
                bikeData,
                bikeTakenData = new Array(48);

            var svg = d3.select("body").append("svg")
                .attr("width", width)
                .attr("height", height);

            function arraysEqual(arr1, arr2) {
                if(arr1.length !== arr2.length)
                    return false;
                for(var i = arr1.length; i--;) {
                    if(arr1[i] !== arr2[i])
                        return false;
                }

                return true;
            }

              // from https://github.com/substack/point-in-polygon
            function pointInPolygon (point, vs) {
                // console.log("[pointInPolygon] ", point, vs);
                var xi, xj, i, intersect,
                    x = point[0],
                    y = point[1],
                    inside = false;
                for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                  xi = vs[i][0],
                  yi = vs[i][1],
                  xj = vs[j][0],
                  yj = vs[j][1],
                  intersect = ((yi > y) != (yj > y))
                      && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                  if (intersect) inside = !inside;
                }
                return inside;
            }

            function update(i) {
                // console.log("[Update] ", i, bikeTakenData);
                var coord;

                var minutes = (i)*30;
                var hours = parseInt(minutes/60);
                var min = minutes-hours*60;
                var timeStr = (hours<10?'0':'') + hours + ":" + (min<10?'0':'') + min;
                // console.log(i, minutes, hours, min, timeStr);
                $("#SelectedTime").text(timeStr);

                svg.selectAll("#circles").remove();

                svg.append('g')
                    .attr('id', 'circles')
                  .selectAll("circle")
                    .data(bikeTakenData[i])
                    .enter()
                    .append('circle')
                    .attr('cx', function(d) {
                        // console.log(d);
                        return projection(d.coords)[0];
                        // coord = projection([d.lng, d.lat]);
                        // return coord[0];
                    })
                    .attr('cy', function(d) {
                        return projection(d.coords)[1];
                        // coord = projection([d.lng, d.lat]);
                        // return coord[1];
                    })
                    .attr('r', '5')
                    .attr('fill', "#333")
                    .attr('opacity', 1);

                // svg.selectAll('g.boundary path').attr('fill', "#f0f");
            }

            $("#time").on('input', function (event) {
                update(this.value);
            });

            Q.all([d3.promise.json("muc.json").then(function(raw) {

                states = topojson.feature(raw, raw.objects.states);

                // Setup the scale and translate

                projection = d3.geo.mercator();
                projection.scale(1).translate([0, 0]);

                path = d3.geo.path().projection(projection);

                var b = path.bounds(states);

                var s = .95 / Math.max((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height);
                var t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2];

                projection = projection.scale(s).translate(t);

                //Color scale

                var map = svg.append('g').attr('class', 'boundary');
                munich = map.selectAll('path').data(states.features);

                //Enter
                munich.enter()
                    .append('path')
                    .attr('d', path)
                    .attr('class', 'disctrict')
                    .attr('data-name', function (d, i) {
                        return d.properties.name.slice(15);
                    })
                    .attr('data-district-nr', function (d, i) {
                        return d.properties.name.slice(12).slice(0,2);
                    });
            }),
            d3.promise.json("data.json")
            ]).then(function (value) {
                timeslots = value[1];

                timeslots.forEach(function (element, myIndex, array) {
                    if (myIndex === array.length-1) {
                        bikeTakenData[array.length-1] = [];
                        return;
                    }

                    bikeTakenData[myIndex] = [];

                    element.forEach(function (place, myElementIndex) {

                        var nextIterBikes = array[myIndex+1].filter(function(elem) {
                            return elem.id === place.id;
                        });

                        if (!nextIterBikes.length) {
                            bikeTakenData[myIndex].push(place);
                        }
                    });
                });

                var pointQueue = [];
                bikeTakenData.forEach(function (bikesTaken) {
                    bikesTaken.forEach(function (bike) {
                        pointQueue.push(bike);
                    });
                })
                var color = d3.scale.linear().domain([0,100]).range(['white', 'green']);

                var boundaryHits = [];

                svg.selectAll('g.boundary path').attr('fill', function(d,i) {
                    boundaryHits[i] = 0;
                    // console.log(i, pointQueue.length);
                    pointQueue.forEach(function (point, myIndex) {

                        var test = pointInPolygon(point.coords, d.geometry.coordinates[0]);
                        if (test) {
                            boundaryHits[i]++;
                            // console.log(i, test);
                            pointQueue.splice(myIndex, 1);
                        }
                    });
                    return color(boundaryHits[i]+2);
                }).attr('data-hits', function (d, i) {
                    return boundaryHits[i];
                });

                update(0);
                $("#time").val(0);
            });


            </script>
    </body>
</html>
